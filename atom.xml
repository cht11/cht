<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Su3&#39;s Blog~</title>
  
  <subtitle>many a little makes a mickle</subtitle>
  <link href="http://example.com/atom.xml" rel="self"/>
  
  <link href="http://example.com/"/>
  <updated>2021-06-16T20:01:14.662Z</updated>
  <id>http://example.com/</id>
  
  <author>
    <name>Su3</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>病毒原理与防范课期末总结</title>
    <link href="http://example.com/2021/06/17/%E7%97%85%E6%AF%92%E5%8E%9F%E7%90%86%E4%B8%8E%E9%98%B2%E8%8C%83%E8%AF%BE%E6%9C%9F%E6%9C%AB%E6%80%BB%E7%BB%93/"/>
    <id>http://example.com/2021/06/17/%E7%97%85%E6%AF%92%E5%8E%9F%E7%90%86%E4%B8%8E%E9%98%B2%E8%8C%83%E8%AF%BE%E6%9C%9F%E6%9C%AB%E6%80%BB%E7%BB%93/</id>
    <published>2021-06-16T19:09:02.000Z</published>
    <updated>2021-06-16T20:01:14.662Z</updated>
    
    <content type="html"><![CDATA[<h1 id="病毒原理与防范——期末总结"><a href="#病毒原理与防范——期末总结" class="headerlink" title="病毒原理与防范——期末总结"></a>病毒原理与防范——期末总结</h1><h2 id="说明"><a href="#说明" class="headerlink" title="说明"></a>说明</h2><p>病毒原理原防范课程的期末总结，根据考试要求，摘抄ppt，以及部分自己的理解。</p><span id="more"></span><h2 id="大纲"><a href="#大纲" class="headerlink" title="大纲"></a>大纲</h2><p><img src="https://gitee.com/cht1/Image/raw/master/20210617031335.png" alt="image-20210617030711292"></p><h2 id="第一章：病毒的基本概念"><a href="#第一章：病毒的基本概念" class="headerlink" title="第一章：病毒的基本概念"></a>第一章：病毒的基本概念</h2><p><img src="https://gitee.com/cht1/Image/raw/master/20210617031341.png" alt="image-20210612170048640"></p><h3 id="1、定义"><a href="#1、定义" class="headerlink" title="1、定义"></a>1、定义</h3><ul><li>计算机病毒是计算机程序中被嵌入的一组破坏性计算机功能或毁坏计算机数据的计算机指令或程序代码。</li></ul><h3 id="2、生命周期"><a href="#2、生命周期" class="headerlink" title="2、生命周期"></a>2、生命周期</h3><ul><li>传染阶段</li><li>潜伏阶段</li><li>触发阶段</li><li>发作阶段：表现/破坏</li></ul><h3 id="3、特性"><a href="#3、特性" class="headerlink" title="3、特性"></a>3、特性</h3><ul><li>传染性</li><li>隐蔽性</li><li>潜伏性</li><li>破坏性</li><li>不可预见性</li></ul><h3 id="4、分类"><a href="#4、分类" class="headerlink" title="4、分类"></a>4、分类</h3><p><strong>按照操作系统</strong>：</p><ul><li>DOS病毒：引导型、文件型、混合型（病毒）</li><li>windows病毒：脚本、宏、PE、网页（病毒）</li><li>其他平台病毒：NIX系列、手机病毒</li></ul><p><strong>按照破坏性</strong>：</p><ul><li>良性病毒：不直接对计算机系统进行破坏</li><li>恶性病毒：破坏计算机系统</li></ul><p><strong>按照传播媒介</strong>：</p><ul><li>单机病毒：载体–磁盘、光盘，通过软盘感染系统传入硬盘 又感染其他软盘</li><li>网络病毒：载体–网络，通过QQ、BBS、Email、FTP、Web等</li></ul><p><strong>按照寄生方式或传染途径</strong>：</p><ul><li>引导型病毒</li><li>文件型病毒</li><li>混合新病毒：引导型兼文件型</li></ul><h3 id="5、计算机病毒的命名"><a href="#5、计算机病毒的命名" class="headerlink" title="5、计算机病毒的命名"></a>5、计算机病毒的命名</h3><p><strong>前缀</strong>+<strong>病毒名</strong>+<strong>后缀</strong></p><ul><li>前缀：病毒发作的<strong>操作系统平台</strong>或病毒的<strong>类型</strong></li><li>病毒名：<strong>名称及其家族</strong></li><li>后缀：可以不要，用于区别该病毒在其家族中病毒的不同（变异）。<ul><li>字母表示某一个家族的第几种变种</li><li>数字表示病毒大小</li><li>可以字母与数字混合作为病毒后缀</li></ul></li></ul><h3 id="6、计算机病毒的设计"><a href="#6、计算机病毒的设计" class="headerlink" title="6、计算机病毒的设计"></a>6、计算机病毒的设计</h3><p><img src="https://gitee.com/cht1/Image/raw/master/20210617031350.png" alt="计算机病毒的设计"></p><h3 id="7、计算机病毒的三种机制"><a href="#7、计算机病毒的三种机制" class="headerlink" title="7、计算机病毒的三种机制"></a>7、计算机病毒的三种机制</h3><ul><li>传染机制：本地感染、网络感染、其他介质传播</li><li>触发机制：日期、时间、击键、启动、特定时间</li><li>破坏机制：格式化系统、删除文件、消耗内存、干扰输出、扰乱输出、破坏硬件、泄露隐私、安装后门、DDos网络服务器</li></ul><h3 id="8、反病毒技术介绍"><a href="#8、反病毒技术介绍" class="headerlink" title="8、反病毒技术介绍"></a>8、反病毒技术介绍</h3><ul><li><p>特征码扫描</p><p>缺点：不能检测变种、新型病毒，特征库越来越大</p></li><li><p>启发式扫描</p><p>缺点：检测结果不准确</p></li><li><p>虚拟机技术：沙箱</p><p>缺点：占用系统资源、影响系统性能、难以准确辨别系统性能</p></li><li><p>主动防御技术：实时监测</p></li><li><p>自免疫技术</p></li></ul><h2 id="第二章：PE文件型病毒——PE结构"><a href="#第二章：PE文件型病毒——PE结构" class="headerlink" title="第二章：PE文件型病毒——PE结构"></a>第二章：PE文件型病毒——PE结构</h2><h3 id="1-PE文件结构"><a href="#1-PE文件结构" class="headerlink" title="1.PE文件结构"></a>1.PE文件结构</h3><p><img src="https://img-blog.csdnimg.cn/20210617035834229.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM1Mjg5NjYw,size_16,color_FFFFFF,t_70" alt="PE文件格式图"></p><ul><li><p>RVA与FOA的转化</p><p><a href="https://blog.csdn.net/qq_35289660/article/details/106264835?spm=1001.2014.3001.5501">PE之FOA与RVA互相转换过程与C语言实现</a></p></li><li><p>导出表工作原理</p><p><a href="https://blog.csdn.net/qq_35289660/article/details/106932627?spm=1001.2014.3001.5501">PE目录项之导出表（解析、移动）</a></p></li><li><p>导入表工作原理</p><p><a href="https://blog.csdn.net/qq_35289660/article/details/107329444?spm=1001.2014.3001.5501">PE导入表和IAT表的原理及工作关系</a></p></li><li><p>节表头字段Characteristics中几个重要的值（属性）</p><table><thead><tr><th>值</th><th>意义</th></tr></thead><tbody><tr><td>20H</td><td>包含代码</td></tr><tr><td>40H</td><td>包含已初始化的数据</td></tr><tr><td>80H</td><td>包含未初始化的数据</td></tr><tr><td>20000000H</td><td>可执行的</td></tr><tr><td>40000000H</td><td>可读的</td></tr><tr><td>80000000H</td><td>可写的</td></tr></tbody></table><p>例如Characteristics为：60000020，就代表该节区包含代码、可执行、可读</p></li></ul><h3 id="2、判断是否为PE文件"><a href="#2、判断是否为PE文件" class="headerlink" title="2、判断是否为PE文件"></a>2、判断是否为PE文件</h3><ol><li><strong>检验文件头部第一个字的值是否等于4D5Ah（“MZ”）</strong>,如果是，则DOS头有效。</li><li>用DOS头的字段e_lfanew来定位PE的NT头，**比较NT头的第一个双字的值是否等于45500000H(“PE\0\0”)**。</li></ol><h3 id="3、获取病毒代码基地址"><a href="#3、获取病毒代码基地址" class="headerlink" title="3、获取病毒代码基地址"></a>3、获取病毒代码基地址</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">         call delta</span><br><span class="line">delta:   pop eax</span><br><span class="line">         sub eax,offset delta </span><br><span class="line">#CALL 指令将返回地址压入堆栈（即CALL的下一条指令地址压入堆栈）</span><br><span class="line">#病毒代码基地址= Delta的地址 - Delta的偏移量</span><br></pre></td></tr></table></figure><h3 id="4、病毒获取API函数地址"><a href="#4、病毒获取API函数地址" class="headerlink" title="4、病毒获取API函数地址"></a>4、病毒获取API函数地址</h3><p><strong>原因</strong>：病毒和普通程序一样需要调用API函数实现某些功能，但病毒运行在宿主环境下，在编写上不能直接写函数名去调用API（引入表提供把函数名转换为函数地址），必须病毒自身去获取API函数地址（动态调用API）。</p><ul><li><p><strong>静态方式</strong>：在源码中include动态库，调用动态库中的函数。</p><p>这样种方法，调用时，根据函数名查引入表，就可以获取该函数的地址。</p></li><li><p><strong>动态方式</strong>：LoadLibrary+GetProcAddress（kernel32.dll中的API函数）</p><p>这种方式是在需要调用函数时才将函数所在的模块调入到内存中，同时也不需要编译器为函数在引入表中建立相应的项。</p></li></ul><p>所以：</p><p>动态方式较好，但要获取kernel32.dll的基地址。（一般每个程序都会默认加载kernel32到内存中）</p><p>然后通过<strong>搜索kernel的导出表得到GetProcAddress和LoadLibrary</strong></p><h3 id="5、获取kernel32地址，即：解决重定位问题"><a href="#5、获取kernel32地址，即：解决重定位问题" class="headerlink" title="5、获取kernel32地址，即：解决重定位问题"></a>5、获取kernel32地址，即：解决重定位问题</h3><h4 id="方法1：程序入口点被kernel32中某个函数调用"><a href="#方法1：程序入口点被kernel32中某个函数调用" class="headerlink" title="方法1：程序入口点被kernel32中某个函数调用"></a>方法1：程序入口点被kernel32中某个函数调用</h4><p>由于程序入口点是被kernel32某个函数调用的，所以这个调用函数肯定在kernel32的地址空间上。</p><p>那么我们只要取得这个返回地址，就得到了一个kernel32空间中的一个地址。</p><p>通过这个地址，我们可以从高地址向低地址方向进行搜索，通过PE标志的判断，搜索到kernel32模块的基地址！</p><h4 id="方法2：通过宿主进程的PEB：进程环境块获得"><a href="#方法2：通过宿主进程的PEB：进程环境块获得" class="headerlink" title="方法2：通过宿主进程的PEB：进程环境块获得"></a>方法2：通过宿主进程的PEB：进程环境块获得</h4><p>Fs寄存器-&gt;TEB</p><p>TEB + 0x30-&gt;PEB</p><p>PEB + 0xc-&gt;PEB_LDR_DATA</p><p>PEB_LDR_DATA+0x1c处存放了一些DLL的地址，第一个是nt.dll地址，第二个就是kernel32.dll的地址了。</p><h4 id="方法3：SEH-结构化异常处理"><a href="#方法3：SEH-结构化异常处理" class="headerlink" title="方法3：SEH(结构化异常处理)"></a>方法3：SEH(结构化异常处理)</h4><p>SEH链表中最顶层的异常处理函数是Kernel32.dll中的一个函数。</p><p>可以遍历这个链表去搜索这个函数地址，通过这个函数地址向低地址方向以64KB为对齐单位查找PE文件的DOS头标志”MZ”，从而找到Kernel32.dll的地址。</p><h4 id="方法4：宿主进程中的TEB，线程环境块"><a href="#方法4：宿主进程中的TEB，线程环境块" class="headerlink" title="方法4：宿主进程中的TEB，线程环境块"></a>方法4：宿主进程中的TEB，线程环境块</h4><p>宿主进程中的TEB：线程环境块，这个块存放了线程的栈顶地址，这个地址+0x1c肯定位于kernel32.dll中（NT系统）。</p><h3 id="6、通过函数名查找函数，获取地址"><a href="#6、通过函数名查找函数，获取地址" class="headerlink" title="6、通过函数名查找函数，获取地址"></a>6、通过函数名查找函数，获取地址</h3><p>遍历pe结构，找到其导出表，然后再：</p><ul><li>导出表工作原理</li></ul><p><a href="https://blog.csdn.net/qq_35289660/article/details/106932627?spm=1001.2014.3001.5501">PE目录项之导出表（解析、移动）</a></p><h3 id="7、PE病毒感染"><a href="#7、PE病毒感染" class="headerlink" title="7、PE病毒感染"></a>7、PE病毒感染</h3><ul><li><p>搜索目标文件：通过API函数（FindFirstFile、FindNextFile）查找文件夹中的PE文件（文件结尾.exe、.dll、.src）</p></li><li><p>文件感染：</p><ul><li><p>一个被病毒感染的HOST程序通常首先执行病毒代码，然后执行HOST程序的正常代码</p><p><strong>即</strong>：修改PE结构的AddressOfEntryPoint字段为恶意代码的RVA，恶意代码尾部通常会跳回原始的AddressOfEntryPoint</p></li><li><p>在HOST程序执行的过程中调用病毒代码</p><p>例如：注入技术、hook技术等</p></li></ul></li><li><p><strong>PE病毒感染途径</strong>（对PE的修改）：注意</p><p><strong>注意</strong>：每一种做法对PE造成什么影响（需要修改PE中的哪些字段信息）</p><ul><li><p><strong>添加节区</strong>：</p><p>要添加一个节区头（节表头），自己定义节表头的各字段信息，并重新计算<strong>SizeofHeaders</strong></p><p>修改字段<strong>NumberOfSection</strong>以及<strong>SizeOfImage</strong></p></li><li><p><strong>扩展节区</strong> ：一般扩展最后一个节区</p><p>更改对应节区的节区头（节表头）字段信息：<strong>SizeOfRawData</strong>、<strong>Characteristics</strong>（如果有代码要 可执行）</p></li><li><p><strong>添加在节区的空隙、空白处</strong> </p><p>这个一般不需要修改，要注意不要覆盖原始数据</p></li></ul><p>这三种做法都是为了添加恶意代码到目标程序中</p></li></ul><p>之后：要获取控制权，即让程序执行我们的恶意代码，这里一般用修改OEP的方式</p><p><strong>即</strong>：修改PE结构的AddressOfEntryPoint字段为恶意代码的RVA，恶意代码尾部通常会跳回原始的AddressOfEntryPoint</p><p>PPT上写的：记录未感染时的AOEP（入口地址），因为在病毒代码结束时要让宿主程序正常执行。所以要先记录AOEP，在病毒程序结束后JMP跳到宿主程序的AOEP。修改OptionalHEADER中的AddressOfEntryPoint，让它指向新加节的入口代码</p><ul><li><p>PPT中的思考题：如果被感染文件的最后一个节表结构和第一个节之间的间距很小，不足以让病毒插入一个新的节表结构，病毒还能感染该文件吗？</p><p>答：</p><ul><li><p>扩展最后一个节区大小，通过修改节表头中的SizeOfRawData，同时也要修改SizeOfImage</p></li><li><p>合并倒数两个节区，然后就多出来一个节区头（节表头），即可在文件尾部添加一个节区。要修改SizeOfImage。</p></li></ul></li></ul><h3 id="8、病毒感染PE文件的基本方法"><a href="#8、病毒感染PE文件的基本方法" class="headerlink" title="8、病毒感染PE文件的基本方法"></a>8、病毒感染PE文件的基本方法</h3><p>添加节区的步骤：</p><ul><li><img src="https://gitee.com/cht1/Image/raw/master/20210617031402.png" alt="image-20210613034546290"></li></ul><p><img src="https://gitee.com/cht1/Image/raw/master/20210617031407.png" alt="image-20210613034557198"></p><p><img src="https://gitee.com/cht1/Image/raw/master/20210617031410.png" alt="image-20210613034838006"></p><h2 id="第三章：引导型病毒——硬盘"><a href="#第三章：引导型病毒——硬盘" class="headerlink" title="第三章：引导型病毒——硬盘"></a>第三章：引导型病毒——硬盘</h2><h3 id="1、定义-1"><a href="#1、定义-1" class="headerlink" title="1、定义"></a>1、定义</h3><p>引导型病毒：专门感染磁盘引导扇区和硬盘主引导扇区的计算机病毒程序</p><h3 id="2、主引导扇区"><a href="#2、主引导扇区" class="headerlink" title="2、主引导扇区"></a>2、主引导扇区</h3><ul><li><p>位置：0磁头、0柱面、1扇区</p></li><li><p>说明：硬盘上的第一个物理扇区</p></li><li><p>包括：<strong>共512字节</strong></p><ul><li><p>主引导记录<strong>MBR</strong>，446字节（512-64-2=446）</p><p>装有操作系统的启动代码</p></li><li><p>主分区表（磁盘分区表），64字节（16*4）</p><p>4张表，记录硬盘分区情况。</p></li><li><p><strong>引导扇区标记</strong>，2字节（0x55,0xAA）</p></li></ul></li></ul><p><img src="https://gitee.com/cht1/Image/raw/master/20210617031418.png" alt="image-20210616132509138"></p><h3 id="3、分区表结构"><a href="#3、分区表结构" class="headerlink" title="3、分区表结构"></a>3、分区表结构</h3><ul><li>16字节的表结构</li></ul><table><thead><tr><th>字段大小/字节</th><th>字段名</th><th>字段含义</th></tr></thead><tbody><tr><td>BYTE：1字节</td><td>State</td><td>分区状态，0=未激活，0x80=激活 即活动分区 装有操作系统，例如C盘，（0x80为可引导分区 00为不可引导分区）</td></tr><tr><td>BYTE：1字节</td><td>StartHead</td><td>分区<strong>起始</strong>磁头号</td></tr><tr><td>WORD：2字节</td><td>StartSC</td><td>分区<strong>起始</strong>柱面号和扇区，由于是2字节（16位），内存中（小端序）取出来为逆序，然后低6位为扇区号，高10位为柱面号</td></tr><tr><td>BYTE：1字节</td><td>Type</td><td>分区类型。0x0b=FAT32，0x83=Linux，0x00代表未使用</td></tr><tr><td>BYTE：1字节</td><td>EndHead</td><td>分区<strong>结束</strong>磁头号</td></tr><tr><td>WORD：2字节</td><td>EndSc</td><td>分区<strong>结束</strong>的柱面号和扇区，与上面的StartSC结构一样。差别是此字段代表结束</td></tr><tr><td>DWORD：4字节</td><td>Relative</td><td>在线性寻址方式下的分区相对扇区地址，（相对于该分区首部）</td></tr><tr><td>DWORD：4字节</td><td>Sectors</td><td>该分区占用的总扇区数，从Related字段起始位置还是计算，单位：扇区数</td></tr></tbody></table><p><img src="https://gitee.com/cht1/Image/raw/master/20210617031421.png" alt="image-20210616133244637"></p><p>上述表中的值，读取的是第一个分区表</p><ul><li>说明：<ul><li>第三个字段StartSC，WORD两字节，代表分区<strong>起始</strong>柱面号和扇区，由于是2字节（16位），内存中（小端序）取出来为逆序，然后低6位为扇区号，高10位为柱面号</li></ul></li></ul><h3 id="4、系统引导过程"><a href="#4、系统引导过程" class="headerlink" title="4、系统引导过程"></a>4、系统引导过程</h3><ul><li>引导过程图</li></ul><p><img src="https://gitee.com/cht1/Image/raw/master/20210617031426.png" alt="image-20210616140858383"></p><ul><li>过程</li></ul><p><img src="https://gitee.com/cht1/Image/raw/master/20210617031430.png" alt="image-20210616141224154"><img src="https://gitee.com/cht1/Image/raw/master/20210617031434.png" alt="image-20210616141621952"></p><p><strong>7dfe由来</strong>：主引导扇区512字节=0x200，其引导标志（0xAA55）的位置为0x1fe和0x1ff两字节。所以由0x7C00+0x1fe=0x7dfe。</p><h3 id="5、引导型病毒"><a href="#5、引导型病毒" class="headerlink" title="5、引导型病毒"></a>5、引导型病毒</h3><ul><li><p>作用：</p><p>MBR（主引导扇区的主引导记录）中装有系统启动代码。</p><p>病毒将恶意代码写入或替换MBR中的系统启动代码。实现每次启动计算机就启动恶意代码。</p></li></ul><p><img src="https://gitee.com/cht1/Image/raw/master/20210617031436.png" alt="image-20210616221241043"></p><p>引导型病毒是利用操作系统的引导模块放在某个固定的位置，并且控制权的转交方式是以物理位置为依据，而不是以操作系统引导区的内容为依据，因而病毒占据该物理位置即可获得控制权，而将真正的引导区内容搬家转移或替换，待病毒程序执行后，将控制权交给真正的引导区内容，使得这个带病毒的系统看似正常运转，而病毒已隐藏在系统中并伺机传染、发作。</p><p><img src="https://gitee.com/cht1/Image/raw/master/20210617031440.png" alt="image-20210616224944391"></p><h3 id="6、引导型病毒的主要技术手段"><a href="#6、引导型病毒的主要技术手段" class="headerlink" title="6、引导型病毒的主要技术手段"></a>6、引导型病毒的主要技术手段</h3><h4 id="（1）常驻内存高端"><a href="#（1）常驻内存高端" class="headerlink" title="（1）常驻内存高端"></a>（1）常驻内存高端</h4><ul><li><p><strong>目的</strong>：把病毒程序载入内存中，且保证这段代码不被其他代码覆盖。</p></li><li><p><strong>内存容量标志单元</strong>：内存0000:0413处两字节描述了基本内存的大小，它的值是KB的倍数。</p></li><li><p><strong>操作方法</strong>：病毒程序首先将自身复制到内存的高端，修改内存容量标志单元，在原有值的基础上减去病毒长度，使得病毒代码能够常驻内存；</p><p>然后将原int 13h磁盘中断服务程序的中断向量保存，并修改此中断向量，将其指向病毒代码，病毒代码因此获得系统控制权，进而执行感染、破坏等工作。</p></li></ul><h4 id="（2）修改中断向量表，截获系统中断"><a href="#（2）修改中断向量表，截获系统中断" class="headerlink" title="（2）修改中断向量表，截获系统中断"></a>（2）修改中断向量表，截获系统中断</h4><h3 id="7、INT-13h-中断"><a href="#7、INT-13h-中断" class="headerlink" title="7、INT 13h 中断"></a>7、INT 13h 中断</h3><p>I/O中断：即写入读取操作</p><ul><li>各字段含义</li></ul><table><thead><tr><th>寄存器（16位）</th><th>高低位</th><th>含义</th></tr></thead><tbody><tr><td>AX</td><td>AH</td><td>状态：02h/r （read读取），03h/w（write写入）</td></tr><tr><td></td><td>AL</td><td>读/写 扇区数</td></tr><tr><td></td><td></td><td></td></tr><tr><td>ES:BX</td><td></td><td>要填充（写入/读取）的缓冲区地址。</td></tr><tr><td></td><td></td><td></td></tr><tr><td>CX</td><td>CH</td><td>磁道号</td></tr><tr><td></td><td>CL</td><td>扇区号</td></tr><tr><td></td><td></td><td></td></tr><tr><td>DX</td><td>DH</td><td>头号</td></tr><tr><td></td><td>DL</td><td>物理驱动器号</td></tr></tbody></table><ul><li>实验三中的第二个实验，用到的int 13h中断（汇编代码前5行）</li></ul><p><img src="https://gitee.com/cht1/Image/raw/master/20210617031445.png" alt="img"></p><h2 id="第四章：网络蠕虫病毒——缓冲区溢出"><a href="#第四章：网络蠕虫病毒——缓冲区溢出" class="headerlink" title="第四章：网络蠕虫病毒——缓冲区溢出"></a>第四章：网络蠕虫病毒——缓冲区溢出</h2><h3 id="1、蠕虫概述"><a href="#1、蠕虫概述" class="headerlink" title="1、蠕虫概述"></a>1、蠕虫概述</h3><ul><li><p><strong>定义</strong>：蠕虫是一种通过网络传播的病毒，可以独立运行，并能把自身的一个包含所有功能的版本传播到另外的计算机</p></li><li><p><strong>网络蠕虫的特点</strong>：</p><ul><li>利用操作系统和应用程序的<strong>漏洞</strong>，<strong>主动进行攻击</strong>（本章：缓冲区溢出漏洞）<ul><li>缓冲区溢出攻击——堆栈、堆</li><li>格式化字符串攻击</li><li>拒绝服务攻击</li><li>弱口令攻击</li><li>默认设置脆弱性攻击</li></ul></li><li>传播方式多样化</li><li>利用网络传播</li></ul></li><li><p>蠕虫行为特征</p><ul><li>主动攻击</li><li>造成网络拥塞</li><li>消耗系统资源，降低系统性能</li><li>产生安全隐患</li><li>反复性</li></ul></li><li><p>工作方式</p><p><img src="https://gitee.com/cht1/Image/raw/master/20210617031448.png" alt="image-20210617001109596"></p></li></ul><h3 id="2、与普通病毒的区别"><a href="#2、与普通病毒的区别" class="headerlink" title="2、与普通病毒的区别"></a>2、与普通病毒的区别</h3><ul><li>相同点<ul><li>传播性</li><li>寄生性</li></ul></li><li>不同点<ul><li>不寄生于与文件或引导扇区</li><li>一般以<strong>独立的文件</strong>或者多个文件存在于磁盘</li><li>以<strong>独立的进程</strong>运行于内存或者寄生在其他进程中</li><li><img src="https://gitee.com/cht1/Image/raw/master/20210617031452.png" alt="image-20210616234554163"></li></ul></li></ul><h3 id="3、缓冲区溢出"><a href="#3、缓冲区溢出" class="headerlink" title="3、缓冲区溢出"></a>3、缓冲区溢出</h3><h4 id="（1）前置知识：函数的返回地址"><a href="#（1）前置知识：函数的返回地址" class="headerlink" title="（1）前置知识：函数的返回地址"></a>（1）前置知识：函数的返回地址</h4><p><a href="https://blog.csdn.net/qq_35289660/article/details/104437975?spm=1001.2014.3001.5501">详解：汇编语言里调用函数的过程和堆栈平衡问题</a></p><h4 id="（2）C语言中的缓冲区溢出原理解析"><a href="#（2）C语言中的缓冲区溢出原理解析" class="headerlink" title="（2）C语言中的缓冲区溢出原理解析"></a>（2）C语言中的缓冲区溢出原理解析</h4><p><a href="https://blog.csdn.net/qq_35289660/article/details/104707842?spm=1001.2014.3001.5501">两个例子：经典缓冲区溢出小例子</a></p><p>建议自己复制代码生成exe用od调试一下。</p><h4 id="（3）原理"><a href="#（3）原理" class="headerlink" title="（3）原理"></a>（3）原理</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">#汇编call指令可以理解为：</span><br><span class="line">#例如：call 0x4010ff</span><br><span class="line">push 函数返回地址#把call指令下一条指令的地址压入堆栈</span><br><span class="line">jmp 0x4010ff</span><br><span class="line"></span><br><span class="line">#然后当0x4010ff处的函数执行完之后，就将之前压入堆栈的函数返回指令pop出来，然后jmp过去（通过ret指令），达到返回上层函数的位置。</span><br></pre></td></tr></table></figure><p>缓冲区溢出，一般就是通过<strong>堆栈中</strong>的数组读写操作（<strong>未控制输入长度</strong>）构造数据，<strong>覆盖堆栈中</strong>的函数返回地址，让函数返回地址为我们设置的地址。</p><h4 id="（4）构造用于覆盖堆栈中函数返回地址的值"><a href="#（4）构造用于覆盖堆栈中函数返回地址的值" class="headerlink" title="（4）构造用于覆盖堆栈中函数返回地址的值"></a>（4）构造用于覆盖堆栈中函数返回地址的值</h4><p>（1）  获取栈溢出覆盖返回地址的正确值，即寻找内存中有jmp esp指令的地址。</p><p><strong>寻找jmp esp的缘由</strong>：</p><p>为了让目标程序执行到shellcode的代码，需将栈溢出覆盖的返回地址指向代码。由于此时esp正好指向那个shellcode的首位置（细节在标题一（1）前置知识：函数的返回地址 中），可以让返回地址返回到jmp esp的代码处，此时esp的位置正好是shellcode代码的开始（因为函数在结尾执行ret指令跳到返回地址之前，已经进行了堆栈平衡，ebp esp已经还原到调用该函数时的初始位置，此时的栈顶esp正好是指向栈溢出覆盖到堆栈的shellcode代码处）。</p><p>所以寻找内存高位kernel32代码中jmp esp指令（内存高位中kernel32每次最先加载，一般不存在重定位问题，即地址多是固定不变）</p><h3 id="4、shellcode"><a href="#4、shellcode" class="headerlink" title="4、shellcode"></a>4、shellcode</h3><ul><li><p><strong>定义</strong>：能完成特殊任务的自包含的二进制代码，根据不同的任务可能是发出一条系统调用或建立的一个高权限的Shell</p></li><li><p><strong>最终目的</strong>：获取机器的控制权</p></li><li><p><strong>特点</strong>：</p><ul><li><strong>长度受限</strong></li><li><strong>不能使用特殊字符</strong>，例如\x00，00会被截断。</li><li><strong>具有自我重定位能力。</strong></li><li>一定的<strong>兼容性</strong></li></ul></li></ul><h3 id="5、缓冲区溢出漏洞的避免方法"><a href="#5、缓冲区溢出漏洞的避免方法" class="headerlink" title="5、缓冲区溢出漏洞的避免方法"></a>5、缓冲区溢出漏洞的避免方法</h3><ol><li>检查容易出错的函数（即未控制输入长度的函数比如scanf、strcpy等）</li><li>数组边界检查，要求代码传递缓冲区的长度</li><li>程序指针完整性检查</li></ol><h3 id="6、蠕虫的防止"><a href="#6、蠕虫的防止" class="headerlink" title="6、蠕虫的防止"></a>6、蠕虫的防止</h3><p>共享文件设置只读权限或设置帐号和密码</p><p>定期检查系统具有可写权限的共享文件夹（管理）</p><p>定期检查计算机的帐户是否有不明帐户</p><h2 id="第五章：木马"><a href="#第五章：木马" class="headerlink" title="第五章：木马"></a>第五章：木马</h2><h3 id="1、概述"><a href="#1、概述" class="headerlink" title="1、概述"></a>1、概述</h3><ul><li><p><strong>定义</strong>：以<strong>窃取信息</strong>、<strong>实施远程监控</strong>等为目的的程序</p></li><li><p><strong>与病毒差别</strong></p><ul><li>定义：<ul><li>病毒是依据其进行<strong>自我复制（传染性）</strong>的特点来定义</li><li>木马依据其<strong>意图</strong>来定义</li></ul></li><li>木马一般不进行感染和传播自身，但也可能具有寄生性，比如捆绑在合法程序中得到安装、启动木马的权限（文件捆绑器、dll劫持）</li><li>木马是广义病毒的一个子类</li></ul></li><li><p>特性：</p><ul><li>欺骗性</li><li>隐蔽性</li><li>自动运行性</li><li>自我保护性</li><li>功能特殊性</li></ul></li></ul><h3 id="2、木马的结构"><a href="#2、木马的结构" class="headerlink" title="2、木马的结构"></a>2、木马的结构</h3><p>木马软件一般由<strong>木马配置程序</strong>、<strong>控制端程序</strong>和<strong>被控端程序</strong>三部分组成</p><p><img src="https://gitee.com/cht1/Image/raw/master/20210617031458.png" alt="image-20210617015326250"></p><ul><li><strong>木马配置程序</strong></li><li><strong>控制端程序</strong></li><li><strong>被控端程序</strong></li></ul><h3 id="3、木马入侵过程"><a href="#3、木马入侵过程" class="headerlink" title="3、木马入侵过程"></a>3、木马入侵过程</h3><p><img src="https://gitee.com/cht1/Image/raw/master/20210617031500.png" alt="image-20210617015709447"></p><ol><li>配置木马</li><li>传播木马</li><li>运行木马</li><li>信息反馈</li><li>建立连接</li><li>远程控制</li></ol><h3 id="4、启动方式"><a href="#4、启动方式" class="headerlink" title="4、启动方式"></a>4、启动方式</h3><ul><li>捆绑应用程序——dll劫持</li><li>修改系统注册表的各种启动项（常用）</li><li>注册为一个系统服务</li><li>应用程序启动组</li><li>修改文件关联</li></ul><h3 id="5、隐藏技术"><a href="#5、隐藏技术" class="headerlink" title="5、隐藏技术"></a>5、隐藏技术</h3><p>隐藏：在进程列表中找不到</p><p><img src="https://gitee.com/cht1/Image/raw/master/20210617031505.png" alt="image-20210617022905412"></p><ul><li><p>伪隐藏：在进程列表中找不到，但是进程<strong>实际仍然存在</strong></p><ul><li>API Hook技术</li></ul></li><li><p>真隐藏：程序彻底的消失。不是进程或服务。</p><ul><li><p><strong>DLL木马技术</strong>：DLL木马就是把一个实现了木马功能的代码，编译成DLL形式。当该DLL被动态绑定时，<strong>DLL入口函数</strong>会被WINDOWS系统调用，此时木马开始执行。</p><ul><li><p><strong>dll劫持</strong>：寻找一个目标dll：A，将目标dll：A改名为C，然后自己写一个dll：B,作用转发dll：C中的所有导出函数，（即可以通过导入dll：B获取到dll：C中的函数），然后将dll：B名字改为A，放入目标dll的相同文件夹中。</p><p>我们的恶意代码只需添加到我们自己写的dll：B中的入口函数，这样，每次假的dll：A被调用，那dll的入口函数就会被WINDOWS系统调用，即调用我们的恶意代码。</p></li><li><p><strong>动态嵌入dll木马</strong>：窗口钩子、远程线程、dll导入表注入。</p></li></ul></li></ul></li></ul><h3 id="6、秘密信道技术：通信协议"><a href="#6、秘密信道技术：通信协议" class="headerlink" title="6、秘密信道技术：通信协议"></a>6、秘密信道技术：通信协议</h3><ul><li>木马程序的数据传递方法：<ul><li>利用<strong>TCP</strong>、<strong>UDP协议</strong>传输数据</li></ul></li><li>隐藏通信的方法：<ul><li>利用<strong>ICMP协议</strong>建立秘密通道</li><li>利用<strong>HTTP协议</strong>建立秘密通道</li></ul></li></ul><h3 id="7、查杀"><a href="#7、查杀" class="headerlink" title="7、查杀"></a>7、查杀</h3><ul><li><p>查看系统目录，按时间进行排序，从<strong>最近添加或者修改的程序中</strong>用调试器或者分析器进行手工查找。</p></li><li><p>专业杀毒软件。</p></li></ul><hr><p><strong>完结</strong>：加油~~</p><hr>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;病毒原理与防范——期末总结&quot;&gt;&lt;a href=&quot;#病毒原理与防范——期末总结&quot; class=&quot;headerlink&quot; title=&quot;病毒原理与防范——期末总结&quot;&gt;&lt;/a&gt;病毒原理与防范——期末总结&lt;/h1&gt;&lt;h2 id=&quot;说明&quot;&gt;&lt;a href=&quot;#说明&quot; class=&quot;headerlink&quot; title=&quot;说明&quot;&gt;&lt;/a&gt;说明&lt;/h2&gt;&lt;p&gt;病毒原理原防范课程的期末总结，根据考试要求，摘抄ppt，以及部分自己的理解。&lt;/p&gt;</summary>
    
    
    
    <category term="课内" scheme="http://example.com/categories/%E8%AF%BE%E5%86%85/"/>
    
    <category term="病毒原理与防范" scheme="http://example.com/categories/%E8%AF%BE%E5%86%85/%E7%97%85%E6%AF%92%E5%8E%9F%E7%90%86%E4%B8%8E%E9%98%B2%E8%8C%83/"/>
    
    
    <category term="课内" scheme="http://example.com/tags/%E8%AF%BE%E5%86%85/"/>
    
    <category term="病毒原理与防范" scheme="http://example.com/tags/%E7%97%85%E6%AF%92%E5%8E%9F%E7%90%86%E4%B8%8E%E9%98%B2%E8%8C%83/"/>
    
    <category term="期末总结" scheme="http://example.com/tags/%E6%9C%9F%E6%9C%AB%E6%80%BB%E7%BB%93/"/>
    
  </entry>
  
  <entry>
    <title>病毒原理与防范课期末总结</title>
    <link href="http://example.com/2021/06/17/1%E7%97%85%E6%AF%92%E5%8E%9F%E7%90%86%E4%B8%8E%E9%98%B2%E8%8C%83%E8%AF%BE%E6%9C%9F%E6%9C%AB%E6%80%BB%E7%BB%93/"/>
    <id>http://example.com/2021/06/17/1%E7%97%85%E6%AF%92%E5%8E%9F%E7%90%86%E4%B8%8E%E9%98%B2%E8%8C%83%E8%AF%BE%E6%9C%9F%E6%9C%AB%E6%80%BB%E7%BB%93/</id>
    <published>2021-06-16T19:09:02.000Z</published>
    <updated>2021-06-16T20:34:57.553Z</updated>
    
    <content type="html"><![CDATA[<h1 id="病毒原理与防范——期末总结"><a href="#病毒原理与防范——期末总结" class="headerlink" title="病毒原理与防范——期末总结"></a>病毒原理与防范——期末总结</h1><h2 id="说明"><a href="#说明" class="headerlink" title="说明"></a>说明</h2><p>病毒原理原防范课程的期末总结，根据考试要求，摘抄ppt，以及部分自己的理解。</p><span id="more"></span><h2 id="大纲"><a href="#大纲" class="headerlink" title="大纲"></a>大纲</h2><p><img src="https://gitee.com/cht1/Image/raw/master/20210617031335.png" alt="image-20210617030711292"></p><h2 id="第一章：病毒的基本概念"><a href="#第一章：病毒的基本概念" class="headerlink" title="第一章：病毒的基本概念"></a>第一章：病毒的基本概念</h2><p><img src="https://gitee.com/cht1/Image/raw/master/20210617031341.png" alt="image-20210612170048640"></p><h3 id="1、定义"><a href="#1、定义" class="headerlink" title="1、定义"></a>1、定义</h3><ul><li>计算机病毒是计算机程序中被嵌入的一组破坏性计算机功能或毁坏计算机数据的计算机指令或程序代码。</li></ul><h3 id="2、生命周期"><a href="#2、生命周期" class="headerlink" title="2、生命周期"></a>2、生命周期</h3><ul><li>传染阶段</li><li>潜伏阶段</li><li>触发阶段</li><li>发作阶段：表现/破坏</li></ul><h3 id="3、特性"><a href="#3、特性" class="headerlink" title="3、特性"></a>3、特性</h3><ul><li>传染性</li><li>隐蔽性</li><li>潜伏性</li><li>破坏性</li><li>不可预见性</li></ul><h3 id="4、分类"><a href="#4、分类" class="headerlink" title="4、分类"></a>4、分类</h3><p><strong>按照操作系统</strong>：</p><ul><li>DOS病毒：引导型、文件型、混合型（病毒）</li><li>windows病毒：脚本、宏、PE、网页（病毒）</li><li>其他平台病毒：NIX系列、手机病毒</li></ul><p><strong>按照破坏性</strong>：</p><ul><li>良性病毒：不直接对计算机系统进行破坏</li><li>恶性病毒：破坏计算机系统</li></ul><p><strong>按照传播媒介</strong>：</p><ul><li>单机病毒：载体–磁盘、光盘，通过软盘感染系统传入硬盘 又感染其他软盘</li><li>网络病毒：载体–网络，通过QQ、BBS、Email、FTP、Web等</li></ul><p><strong>按照寄生方式或传染途径</strong>：</p><ul><li>引导型病毒</li><li>文件型病毒</li><li>混合新病毒：引导型兼文件型</li></ul><h3 id="5、计算机病毒的命名"><a href="#5、计算机病毒的命名" class="headerlink" title="5、计算机病毒的命名"></a>5、计算机病毒的命名</h3><p><strong>前缀</strong>+<strong>病毒名</strong>+<strong>后缀</strong></p><ul><li>前缀：病毒发作的<strong>操作系统平台</strong>或病毒的<strong>类型</strong></li><li>病毒名：<strong>名称及其家族</strong></li><li>后缀：可以不要，用于区别该病毒在其家族中病毒的不同（变异）。<ul><li>字母表示某一个家族的第几种变种</li><li>数字表示病毒大小</li><li>可以字母与数字混合作为病毒后缀</li></ul></li></ul><h3 id="6、计算机病毒的设计"><a href="#6、计算机病毒的设计" class="headerlink" title="6、计算机病毒的设计"></a>6、计算机病毒的设计</h3><p><img src="https://gitee.com/cht1/Image/raw/master/20210617031350.png" alt="计算机病毒的设计"></p><h3 id="7、计算机病毒的三种机制"><a href="#7、计算机病毒的三种机制" class="headerlink" title="7、计算机病毒的三种机制"></a>7、计算机病毒的三种机制</h3><ul><li>传染机制：本地感染、网络感染、其他介质传播</li><li>触发机制：日期、时间、击键、启动、特定时间</li><li>破坏机制：格式化系统、删除文件、消耗内存、干扰输出、扰乱输出、破坏硬件、泄露隐私、安装后门、DDos网络服务器</li></ul><h3 id="8、反病毒技术介绍"><a href="#8、反病毒技术介绍" class="headerlink" title="8、反病毒技术介绍"></a>8、反病毒技术介绍</h3><ul><li><p>特征码扫描</p><p>缺点：不能检测变种、新型病毒，特征库越来越大</p></li><li><p>启发式扫描</p><p>缺点：检测结果不准确</p></li><li><p>虚拟机技术：沙箱</p><p>缺点：占用系统资源、影响系统性能、难以准确辨别系统性能</p></li><li><p>主动防御技术：实时监测</p></li><li><p>自免疫技术</p></li></ul><h2 id="第二章：PE文件型病毒——PE结构"><a href="#第二章：PE文件型病毒——PE结构" class="headerlink" title="第二章：PE文件型病毒——PE结构"></a>第二章：PE文件型病毒——PE结构</h2><h3 id="1-PE文件结构"><a href="#1-PE文件结构" class="headerlink" title="1.PE文件结构"></a>1.PE文件结构</h3><p><img src="https://img-blog.csdnimg.cn/20210617035834229.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM1Mjg5NjYw,size_16,color_FFFFFF,t_70" alt="PE文件格式图"></p><ul><li><p>RVA与FOA的转化</p><p><a href="https://blog.csdn.net/qq_35289660/article/details/106264835?spm=1001.2014.3001.5501">PE之FOA与RVA互相转换过程与C语言实现</a></p></li><li><p>导出表工作原理</p><p><a href="https://blog.csdn.net/qq_35289660/article/details/106932627?spm=1001.2014.3001.5501">PE目录项之导出表（解析、移动）</a></p></li><li><p>导入表工作原理</p><p><a href="https://blog.csdn.net/qq_35289660/article/details/107329444?spm=1001.2014.3001.5501">PE导入表和IAT表的原理及工作关系</a></p></li><li><p>节表头字段Characteristics中几个重要的值（属性）</p><table><thead><tr><th>值</th><th>意义</th></tr></thead><tbody><tr><td>20H</td><td>包含代码</td></tr><tr><td>40H</td><td>包含已初始化的数据</td></tr><tr><td>80H</td><td>包含未初始化的数据</td></tr><tr><td>20000000H</td><td>可执行的</td></tr><tr><td>40000000H</td><td>可读的</td></tr><tr><td>80000000H</td><td>可写的</td></tr></tbody></table><p>例如Characteristics为：60000020，就代表该节区包含代码、可执行、可读</p></li></ul><h3 id="2、判断是否为PE文件"><a href="#2、判断是否为PE文件" class="headerlink" title="2、判断是否为PE文件"></a>2、判断是否为PE文件</h3><ol><li><strong>检验文件头部第一个字的值是否等于4D5Ah（“MZ”）</strong>,如果是，则DOS头有效。</li><li>用DOS头的字段e_lfanew来定位PE的NT头，**比较NT头的第一个双字的值是否等于45500000H(“PE\0\0”)**。</li></ol><h3 id="3、获取病毒代码基地址"><a href="#3、获取病毒代码基地址" class="headerlink" title="3、获取病毒代码基地址"></a>3、获取病毒代码基地址</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">         call delta</span><br><span class="line">delta:   pop eax</span><br><span class="line">         sub eax,offset delta </span><br><span class="line">#CALL 指令将返回地址压入堆栈（即CALL的下一条指令地址压入堆栈）</span><br><span class="line">#病毒代码基地址= Delta的地址 - Delta的偏移量</span><br></pre></td></tr></table></figure><h3 id="4、病毒获取API函数地址"><a href="#4、病毒获取API函数地址" class="headerlink" title="4、病毒获取API函数地址"></a>4、病毒获取API函数地址</h3><p><strong>原因</strong>：病毒和普通程序一样需要调用API函数实现某些功能，但病毒运行在宿主环境下，在编写上不能直接写函数名去调用API（引入表提供把函数名转换为函数地址），必须病毒自身去获取API函数地址（动态调用API）。</p><ul><li><p><strong>静态方式</strong>：在源码中include动态库，调用动态库中的函数。</p><p>这样种方法，调用时，根据函数名查引入表，就可以获取该函数的地址。</p></li><li><p><strong>动态方式</strong>：LoadLibrary+GetProcAddress（kernel32.dll中的API函数）</p><p>这种方式是在需要调用函数时才将函数所在的模块调入到内存中，同时也不需要编译器为函数在引入表中建立相应的项。</p></li></ul><p>所以：</p><p>动态方式较好，但要获取kernel32.dll的基地址。（一般每个程序都会默认加载kernel32到内存中）</p><p>然后通过<strong>搜索kernel的导出表得到GetProcAddress和LoadLibrary</strong></p><h3 id="5、获取kernel32地址，即：解决重定位问题"><a href="#5、获取kernel32地址，即：解决重定位问题" class="headerlink" title="5、获取kernel32地址，即：解决重定位问题"></a>5、获取kernel32地址，即：解决重定位问题</h3><h4 id="方法1：程序入口点被kernel32中某个函数调用"><a href="#方法1：程序入口点被kernel32中某个函数调用" class="headerlink" title="方法1：程序入口点被kernel32中某个函数调用"></a>方法1：程序入口点被kernel32中某个函数调用</h4><p>由于程序入口点是被kernel32某个函数调用的，所以这个调用函数肯定在kernel32的地址空间上。</p><p>那么我们只要取得这个返回地址，就得到了一个kernel32空间中的一个地址。</p><p>通过这个地址，我们可以从高地址向低地址方向进行搜索，通过PE标志的判断，搜索到kernel32模块的基地址！</p><h4 id="方法2：通过宿主进程的PEB：进程环境块获得"><a href="#方法2：通过宿主进程的PEB：进程环境块获得" class="headerlink" title="方法2：通过宿主进程的PEB：进程环境块获得"></a>方法2：通过宿主进程的PEB：进程环境块获得</h4><p>Fs寄存器-&gt;TEB</p><p>TEB + 0x30-&gt;PEB</p><p>PEB + 0xc-&gt;PEB_LDR_DATA</p><p>PEB_LDR_DATA+0x1c处存放了一些DLL的地址，第一个是nt.dll地址，第二个就是kernel32.dll的地址了。</p><h4 id="方法3：SEH-结构化异常处理"><a href="#方法3：SEH-结构化异常处理" class="headerlink" title="方法3：SEH(结构化异常处理)"></a>方法3：SEH(结构化异常处理)</h4><p>SEH链表中最顶层的异常处理函数是Kernel32.dll中的一个函数。</p><p>可以遍历这个链表去搜索这个函数地址，通过这个函数地址向低地址方向以64KB为对齐单位查找PE文件的DOS头标志”MZ”，从而找到Kernel32.dll的地址。</p><h4 id="方法4：宿主进程中的TEB，线程环境块"><a href="#方法4：宿主进程中的TEB，线程环境块" class="headerlink" title="方法4：宿主进程中的TEB，线程环境块"></a>方法4：宿主进程中的TEB，线程环境块</h4><p>宿主进程中的TEB：线程环境块，这个块存放了线程的栈顶地址，这个地址+0x1c肯定位于kernel32.dll中（NT系统）。</p><h3 id="6、通过函数名查找函数，获取地址"><a href="#6、通过函数名查找函数，获取地址" class="headerlink" title="6、通过函数名查找函数，获取地址"></a>6、通过函数名查找函数，获取地址</h3><p>遍历pe结构，找到其导出表，然后再：</p><ul><li>导出表工作原理</li></ul><p><a href="https://blog.csdn.net/qq_35289660/article/details/106932627?spm=1001.2014.3001.5501">PE目录项之导出表（解析、移动）</a></p><h3 id="7、PE病毒感染"><a href="#7、PE病毒感染" class="headerlink" title="7、PE病毒感染"></a>7、PE病毒感染</h3><ul><li><p>搜索目标文件：通过API函数（FindFirstFile、FindNextFile）查找文件夹中的PE文件（文件结尾.exe、.dll、.src）</p></li><li><p>文件感染：</p><ul><li><p>一个被病毒感染的HOST程序通常首先执行病毒代码，然后执行HOST程序的正常代码</p><p><strong>即</strong>：修改PE结构的AddressOfEntryPoint字段为恶意代码的RVA，恶意代码尾部通常会跳回原始的AddressOfEntryPoint</p></li><li><p>在HOST程序执行的过程中调用病毒代码</p><p>例如：注入技术、hook技术等</p></li></ul></li><li><p><strong>PE病毒感染途径</strong>（对PE的修改）：注意</p><p><strong>注意</strong>：每一种做法对PE造成什么影响（需要修改PE中的哪些字段信息）</p><ul><li><p><strong>添加节区</strong>：</p><p>要添加一个节区头（节表头），自己定义节表头的各字段信息，并重新计算<strong>SizeofHeaders</strong></p><p>修改字段<strong>NumberOfSection</strong>以及<strong>SizeOfImage</strong></p></li><li><p><strong>扩展节区</strong> ：一般扩展最后一个节区</p><p>更改对应节区的节区头（节表头）字段信息：<strong>SizeOfRawData</strong>、<strong>Characteristics</strong>（如果有代码要 可执行）</p></li><li><p><strong>添加在节区的空隙、空白处</strong> </p><p>这个一般不需要修改，要注意不要覆盖原始数据</p></li></ul><p>这三种做法都是为了添加恶意代码到目标程序中</p></li></ul><p>之后：要获取控制权，即让程序执行我们的恶意代码，这里一般用修改OEP的方式</p><p><strong>即</strong>：修改PE结构的AddressOfEntryPoint字段为恶意代码的RVA，恶意代码尾部通常会跳回原始的AddressOfEntryPoint</p><p>PPT上写的：记录未感染时的AOEP（入口地址），因为在病毒代码结束时要让宿主程序正常执行。所以要先记录AOEP，在病毒程序结束后JMP跳到宿主程序的AOEP。修改OptionalHEADER中的AddressOfEntryPoint，让它指向新加节的入口代码</p><ul><li><p>PPT中的思考题：如果被感染文件的最后一个节表结构和第一个节之间的间距很小，不足以让病毒插入一个新的节表结构，病毒还能感染该文件吗？</p><p>答：</p><ul><li><p>扩展最后一个节区大小，通过修改节表头中的SizeOfRawData，同时也要修改SizeOfImage</p></li><li><p>合并倒数两个节区，然后就多出来一个节区头（节表头），即可在文件尾部添加一个节区。要修改SizeOfImage。</p></li></ul></li></ul><h3 id="8、病毒感染PE文件的基本方法"><a href="#8、病毒感染PE文件的基本方法" class="headerlink" title="8、病毒感染PE文件的基本方法"></a>8、病毒感染PE文件的基本方法</h3><p>添加节区的步骤：</p><ul><li><img src="https://gitee.com/cht1/Image/raw/master/20210617031402.png" alt="image-20210613034546290"></li></ul><p><img src="https://gitee.com/cht1/Image/raw/master/20210617031407.png" alt="image-20210613034557198"></p><p><img src="https://gitee.com/cht1/Image/raw/master/20210617031410.png" alt="image-20210613034838006"></p><h2 id="第三章：引导型病毒——硬盘"><a href="#第三章：引导型病毒——硬盘" class="headerlink" title="第三章：引导型病毒——硬盘"></a>第三章：引导型病毒——硬盘</h2><h3 id="1、定义-1"><a href="#1、定义-1" class="headerlink" title="1、定义"></a>1、定义</h3><p>引导型病毒：专门感染磁盘引导扇区和硬盘主引导扇区的计算机病毒程序</p><h3 id="2、主引导扇区"><a href="#2、主引导扇区" class="headerlink" title="2、主引导扇区"></a>2、主引导扇区</h3><ul><li><p>位置：0磁头、0柱面、1扇区</p></li><li><p>说明：硬盘上的第一个物理扇区</p></li><li><p>包括：<strong>共512字节</strong></p><ul><li><p>主引导记录<strong>MBR</strong>，446字节（512-64-2=446）</p><p>装有操作系统的启动代码</p></li><li><p>主分区表（磁盘分区表），64字节（16*4）</p><p>4张表，记录硬盘分区情况。</p></li><li><p><strong>引导扇区标记</strong>，2字节（0x55,0xAA）</p></li></ul></li></ul><p><img src="https://gitee.com/cht1/Image/raw/master/20210617031418.png" alt="image-20210616132509138"></p><h3 id="3、分区表结构"><a href="#3、分区表结构" class="headerlink" title="3、分区表结构"></a>3、分区表结构</h3><ul><li>16字节的表结构</li></ul><table><thead><tr><th>字段大小/字节</th><th>字段名</th><th>字段含义</th></tr></thead><tbody><tr><td>BYTE：1字节</td><td>State</td><td>分区状态，0=未激活，0x80=激活 即活动分区 装有操作系统，例如C盘，（0x80为可引导分区 00为不可引导分区）</td></tr><tr><td>BYTE：1字节</td><td>StartHead</td><td>分区<strong>起始</strong>磁头号</td></tr><tr><td>WORD：2字节</td><td>StartSC</td><td>分区<strong>起始</strong>柱面号和扇区，由于是2字节（16位），内存中（小端序）取出来为逆序，然后低6位为扇区号，高10位为柱面号</td></tr><tr><td>BYTE：1字节</td><td>Type</td><td>分区类型。0x0b=FAT32，0x83=Linux，0x00代表未使用</td></tr><tr><td>BYTE：1字节</td><td>EndHead</td><td>分区<strong>结束</strong>磁头号</td></tr><tr><td>WORD：2字节</td><td>EndSc</td><td>分区<strong>结束</strong>的柱面号和扇区，与上面的StartSC结构一样。差别是此字段代表结束</td></tr><tr><td>DWORD：4字节</td><td>Relative</td><td>在线性寻址方式下的分区相对扇区地址，（相对于该分区首部）</td></tr><tr><td>DWORD：4字节</td><td>Sectors</td><td>该分区占用的总扇区数，从Related字段起始位置还是计算，单位：扇区数</td></tr></tbody></table><p><img src="https://gitee.com/cht1/Image/raw/master/20210617031421.png" alt="image-20210616133244637"></p><p>上述表中的值，读取的是第一个分区表</p><ul><li>说明：<ul><li>第三个字段StartSC，WORD两字节，代表分区<strong>起始</strong>柱面号和扇区，由于是2字节（16位），内存中（小端序）取出来为逆序，然后低6位为扇区号，高10位为柱面号</li></ul></li></ul><h3 id="4、系统引导过程"><a href="#4、系统引导过程" class="headerlink" title="4、系统引导过程"></a>4、系统引导过程</h3><ul><li>引导过程图</li></ul><p><img src="https://gitee.com/cht1/Image/raw/master/20210617031426.png" alt="image-20210616140858383"></p><ul><li>过程</li></ul><p><img src="https://gitee.com/cht1/Image/raw/master/20210617031430.png" alt="image-20210616141224154"><img src="https://gitee.com/cht1/Image/raw/master/20210617031434.png" alt="image-20210616141621952"></p><p><strong>7dfe由来</strong>：主引导扇区512字节=0x200，其引导标志（0xAA55）的位置为0x1fe和0x1ff两字节。所以由0x7C00+0x1fe=0x7dfe。</p><h3 id="5、引导型病毒"><a href="#5、引导型病毒" class="headerlink" title="5、引导型病毒"></a>5、引导型病毒</h3><ul><li><p>作用：</p><p>MBR（主引导扇区的主引导记录）中装有系统启动代码。</p><p>病毒将恶意代码写入或替换MBR中的系统启动代码。实现每次启动计算机就启动恶意代码。</p></li></ul><p><img src="https://gitee.com/cht1/Image/raw/master/20210617031436.png" alt="image-20210616221241043"></p><p>引导型病毒是利用操作系统的引导模块放在某个固定的位置，并且控制权的转交方式是以物理位置为依据，而不是以操作系统引导区的内容为依据，因而病毒占据该物理位置即可获得控制权，而将真正的引导区内容搬家转移或替换，待病毒程序执行后，将控制权交给真正的引导区内容，使得这个带病毒的系统看似正常运转，而病毒已隐藏在系统中并伺机传染、发作。</p><p><img src="https://gitee.com/cht1/Image/raw/master/20210617031440.png" alt="image-20210616224944391"></p><h3 id="6、引导型病毒的主要技术手段"><a href="#6、引导型病毒的主要技术手段" class="headerlink" title="6、引导型病毒的主要技术手段"></a>6、引导型病毒的主要技术手段</h3><h4 id="（1）常驻内存高端"><a href="#（1）常驻内存高端" class="headerlink" title="（1）常驻内存高端"></a>（1）常驻内存高端</h4><ul><li><p><strong>目的</strong>：把病毒程序载入内存中，且保证这段代码不被其他代码覆盖。</p></li><li><p><strong>内存容量标志单元</strong>：内存0000:0413处两字节描述了基本内存的大小，它的值是KB的倍数。</p></li><li><p><strong>操作方法</strong>：病毒程序首先将自身复制到内存的高端，修改内存容量标志单元，在原有值的基础上减去病毒长度，使得病毒代码能够常驻内存；</p><p>然后将原int 13h磁盘中断服务程序的中断向量保存，并修改此中断向量，将其指向病毒代码，病毒代码因此获得系统控制权，进而执行感染、破坏等工作。</p></li></ul><h4 id="（2）修改中断向量表，截获系统中断"><a href="#（2）修改中断向量表，截获系统中断" class="headerlink" title="（2）修改中断向量表，截获系统中断"></a>（2）修改中断向量表，截获系统中断</h4><h3 id="7、INT-13h-中断"><a href="#7、INT-13h-中断" class="headerlink" title="7、INT 13h 中断"></a>7、INT 13h 中断</h3><p>I/O中断：即写入读取操作</p><ul><li>各字段含义</li></ul><table><thead><tr><th>寄存器（16位）</th><th>高低位</th><th>含义</th></tr></thead><tbody><tr><td>AX</td><td>AH</td><td>状态：02h/r （read读取），03h/w（write写入）</td></tr><tr><td></td><td>AL</td><td>读/写 扇区数</td></tr><tr><td></td><td></td><td></td></tr><tr><td>ES:BX</td><td></td><td>要填充（写入/读取）的缓冲区地址。</td></tr><tr><td></td><td></td><td></td></tr><tr><td>CX</td><td>CH</td><td>磁道号</td></tr><tr><td></td><td>CL</td><td>扇区号</td></tr><tr><td></td><td></td><td></td></tr><tr><td>DX</td><td>DH</td><td>头号</td></tr><tr><td></td><td>DL</td><td>物理驱动器号</td></tr></tbody></table><ul><li>实验三中的第二个实验，用到的int 13h中断（汇编代码前5行）</li></ul><p><img src="https://gitee.com/cht1/Image/raw/master/20210617031445.png" alt="img"></p><h2 id="第四章：网络蠕虫病毒——缓冲区溢出"><a href="#第四章：网络蠕虫病毒——缓冲区溢出" class="headerlink" title="第四章：网络蠕虫病毒——缓冲区溢出"></a>第四章：网络蠕虫病毒——缓冲区溢出</h2><h3 id="1、蠕虫概述"><a href="#1、蠕虫概述" class="headerlink" title="1、蠕虫概述"></a>1、蠕虫概述</h3><ul><li><p><strong>定义</strong>：蠕虫是一种通过网络传播的病毒，可以独立运行，并能把自身的一个包含所有功能的版本传播到另外的计算机</p></li><li><p><strong>网络蠕虫的特点</strong>：</p><ul><li>利用操作系统和应用程序的<strong>漏洞</strong>，<strong>主动进行攻击</strong>（本章：缓冲区溢出漏洞）<ul><li>缓冲区溢出攻击——堆栈、堆</li><li>格式化字符串攻击</li><li>拒绝服务攻击</li><li>弱口令攻击</li><li>默认设置脆弱性攻击</li></ul></li><li>传播方式多样化</li><li>利用网络传播</li></ul></li><li><p>蠕虫行为特征</p><ul><li>主动攻击</li><li>造成网络拥塞</li><li>消耗系统资源，降低系统性能</li><li>产生安全隐患</li><li>反复性</li></ul></li><li><p>工作方式</p><p><img src="https://gitee.com/cht1/Image/raw/master/20210617031448.png" alt="image-20210617001109596"></p></li></ul><h3 id="2、与普通病毒的区别"><a href="#2、与普通病毒的区别" class="headerlink" title="2、与普通病毒的区别"></a>2、与普通病毒的区别</h3><ul><li>相同点<ul><li>传播性</li><li>寄生性</li></ul></li><li>不同点<ul><li>不寄生于与文件或引导扇区</li><li>一般以<strong>独立的文件</strong>或者多个文件存在于磁盘</li><li>以<strong>独立的进程</strong>运行于内存或者寄生在其他进程中</li><li><img src="https://gitee.com/cht1/Image/raw/master/20210617031452.png" alt="image-20210616234554163"></li></ul></li></ul><h3 id="3、缓冲区溢出"><a href="#3、缓冲区溢出" class="headerlink" title="3、缓冲区溢出"></a>3、缓冲区溢出</h3><h4 id="（1）前置知识：函数的返回地址"><a href="#（1）前置知识：函数的返回地址" class="headerlink" title="（1）前置知识：函数的返回地址"></a>（1）前置知识：函数的返回地址</h4><p><a href="https://blog.csdn.net/qq_35289660/article/details/104437975?spm=1001.2014.3001.5501">详解：汇编语言里调用函数的过程和堆栈平衡问题</a></p><h4 id="（2）C语言中的缓冲区溢出原理解析"><a href="#（2）C语言中的缓冲区溢出原理解析" class="headerlink" title="（2）C语言中的缓冲区溢出原理解析"></a>（2）C语言中的缓冲区溢出原理解析</h4><p><a href="https://blog.csdn.net/qq_35289660/article/details/104707842?spm=1001.2014.3001.5501">两个例子：经典缓冲区溢出小例子</a></p><p>建议自己复制代码生成exe用od调试一下。</p><h4 id="（3）原理"><a href="#（3）原理" class="headerlink" title="（3）原理"></a>（3）原理</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">#汇编call指令可以理解为：</span><br><span class="line">#例如：call 0x4010ff</span><br><span class="line">push 函数返回地址#把call指令下一条指令的地址压入堆栈</span><br><span class="line">jmp 0x4010ff</span><br><span class="line"></span><br><span class="line">#然后当0x4010ff处的函数执行完之后，就将之前压入堆栈的函数返回指令pop出来，然后jmp过去（通过ret指令），达到返回上层函数的位置。</span><br></pre></td></tr></table></figure><p>缓冲区溢出，一般就是通过<strong>堆栈中</strong>的数组读写操作（<strong>未控制输入长度</strong>）构造数据，<strong>覆盖堆栈中</strong>的函数返回地址，让函数返回地址为我们设置的地址。</p><h4 id="（4）构造用于覆盖堆栈中函数返回地址的值"><a href="#（4）构造用于覆盖堆栈中函数返回地址的值" class="headerlink" title="（4）构造用于覆盖堆栈中函数返回地址的值"></a>（4）构造用于覆盖堆栈中函数返回地址的值</h4><p>（1）  获取栈溢出覆盖返回地址的正确值，即寻找内存中有jmp esp指令的地址。</p><p><strong>寻找jmp esp的缘由</strong>：</p><p>为了让目标程序执行到shellcode的代码，需将栈溢出覆盖的返回地址指向代码。由于此时esp正好指向那个shellcode的首位置（细节在标题一（1）前置知识：函数的返回地址 中），可以让返回地址返回到jmp esp的代码处，此时esp的位置正好是shellcode代码的开始（因为函数在结尾执行ret指令跳到返回地址之前，已经进行了堆栈平衡，ebp esp已经还原到调用该函数时的初始位置，此时的栈顶esp正好是指向栈溢出覆盖到堆栈的shellcode代码处）。</p><p>所以寻找内存高位kernel32代码中jmp esp指令（内存高位中kernel32每次最先加载，一般不存在重定位问题，即地址多是固定不变）</p><h3 id="4、shellcode"><a href="#4、shellcode" class="headerlink" title="4、shellcode"></a>4、shellcode</h3><ul><li><p><strong>定义</strong>：能完成特殊任务的自包含的二进制代码，根据不同的任务可能是发出一条系统调用或建立的一个高权限的Shell</p></li><li><p><strong>最终目的</strong>：获取机器的控制权</p></li><li><p><strong>特点</strong>：</p><ul><li><strong>长度受限</strong></li><li><strong>不能使用特殊字符</strong>，例如\x00，00会被截断。</li><li><strong>具有自我重定位能力。</strong></li><li>一定的<strong>兼容性</strong></li></ul></li></ul><h3 id="5、缓冲区溢出漏洞的避免方法"><a href="#5、缓冲区溢出漏洞的避免方法" class="headerlink" title="5、缓冲区溢出漏洞的避免方法"></a>5、缓冲区溢出漏洞的避免方法</h3><ol><li>检查容易出错的函数（即未控制输入长度的函数比如scanf、strcpy等）</li><li>数组边界检查，要求代码传递缓冲区的长度</li><li>程序指针完整性检查</li></ol><h3 id="6、蠕虫的防止"><a href="#6、蠕虫的防止" class="headerlink" title="6、蠕虫的防止"></a>6、蠕虫的防止</h3><p>共享文件设置只读权限或设置帐号和密码</p><p>定期检查系统具有可写权限的共享文件夹（管理）</p><p>定期检查计算机的帐户是否有不明帐户</p><h2 id="第五章：木马"><a href="#第五章：木马" class="headerlink" title="第五章：木马"></a>第五章：木马</h2><h3 id="1、概述"><a href="#1、概述" class="headerlink" title="1、概述"></a>1、概述</h3><ul><li><p><strong>定义</strong>：以<strong>窃取信息</strong>、<strong>实施远程监控</strong>等为目的的程序</p></li><li><p><strong>与病毒差别</strong></p><ul><li>定义：<ul><li>病毒是依据其进行<strong>自我复制（传染性）</strong>的特点来定义</li><li>木马依据其<strong>意图</strong>来定义</li></ul></li><li>木马一般不进行感染和传播自身，但也可能具有寄生性，比如捆绑在合法程序中得到安装、启动木马的权限（文件捆绑器、dll劫持）</li><li>木马是广义病毒的一个子类</li></ul></li><li><p>特性：</p><ul><li>欺骗性</li><li>隐蔽性</li><li>自动运行性</li><li>自我保护性</li><li>功能特殊性</li></ul></li></ul><h3 id="2、木马的结构"><a href="#2、木马的结构" class="headerlink" title="2、木马的结构"></a>2、木马的结构</h3><p>木马软件一般由<strong>木马配置程序</strong>、<strong>控制端程序</strong>和<strong>被控端程序</strong>三部分组成</p><p><img src="https://gitee.com/cht1/Image/raw/master/20210617031458.png" alt="image-20210617015326250"></p><ul><li><strong>木马配置程序</strong></li><li><strong>控制端程序</strong></li><li><strong>被控端程序</strong></li></ul><h3 id="3、木马入侵过程"><a href="#3、木马入侵过程" class="headerlink" title="3、木马入侵过程"></a>3、木马入侵过程</h3><p><img src="https://gitee.com/cht1/Image/raw/master/20210617031500.png" alt="image-20210617015709447"></p><ol><li>配置木马</li><li>传播木马</li><li>运行木马</li><li>信息反馈</li><li>建立连接</li><li>远程控制</li></ol><h3 id="4、启动方式"><a href="#4、启动方式" class="headerlink" title="4、启动方式"></a>4、启动方式</h3><ul><li>捆绑应用程序——dll劫持</li><li>修改系统注册表的各种启动项（常用）</li><li>注册为一个系统服务</li><li>应用程序启动组</li><li>修改文件关联</li></ul><h3 id="5、隐藏技术"><a href="#5、隐藏技术" class="headerlink" title="5、隐藏技术"></a>5、隐藏技术</h3><p>隐藏：在进程列表中找不到</p><p><img src="https://gitee.com/cht1/Image/raw/master/20210617031505.png" alt="image-20210617022905412"></p><ul><li><p>伪隐藏：在进程列表中找不到，但是进程<strong>实际仍然存在</strong></p></li><li><p>API Hook技术</p></li><li><p>真隐藏：程序彻底的消失。不是进程或服务。</p><ul><li><p><strong>DLL木马技术</strong>：DLL木马就是把一个实现了木马功能的代码，编译成DLL形式。当该DLL被动态绑定时，<strong>DLL入口函数</strong>会被WINDOWS系统调用，此时木马开始执行。</p><ul><li><p><strong>dll劫持</strong>：寻找一个目标dll：A，将目标dll：A改名为C，然后自己写一个dll：B,作用转发dll：C中的所有导出函数，（即可以通过导入dll：B获取到dll：C中的函数），然后将dll：B名字改为A，放入目标dll的相同文件夹中。</p><p>我们的恶意代码只需添加到我们自己写的dll：B中的入口函数，这样，每次假的dll：A被调用，那dll的入口函数就会被WINDOWS系统调用，即调用我们的恶意代码。</p></li><li><p><strong>动态嵌入dll木马</strong>：窗口钩子、远程线程、dll导入表注入。</p></li></ul></li></ul></li></ul><h3 id="6、秘密信道技术：通信协议"><a href="#6、秘密信道技术：通信协议" class="headerlink" title="6、秘密信道技术：通信协议"></a>6、秘密信道技术：通信协议</h3><ul><li>木马程序的数据传递方法：<ul><li>利用<strong>TCP</strong>、<strong>UDP协议</strong>传输数据</li></ul></li><li>隐藏通信的方法：<ul><li>利用<strong>ICMP协议</strong>建立秘密通道</li><li>利用<strong>HTTP协议</strong>建立秘密通道</li></ul></li></ul><h3 id="7、查杀"><a href="#7、查杀" class="headerlink" title="7、查杀"></a>7、查杀</h3><ul><li><p>查看系统目录，按时间进行排序，从<strong>最近添加或者修改的程序中</strong>用调试器或者分析器进行手工查找。</p></li><li><p>专业杀毒软件。</p></li></ul><hr><p><strong>完结</strong>：加油~~</p><hr>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;病毒原理与防范——期末总结&quot;&gt;&lt;a href=&quot;#病毒原理与防范——期末总结&quot; class=&quot;headerlink&quot; title=&quot;病毒原理与防范——期末总结&quot;&gt;&lt;/a&gt;病毒原理与防范——期末总结&lt;/h1&gt;&lt;h2 id=&quot;说明&quot;&gt;&lt;a href=&quot;#说明&quot; class=&quot;headerlink&quot; title=&quot;说明&quot;&gt;&lt;/a&gt;说明&lt;/h2&gt;&lt;p&gt;病毒原理原防范课程的期末总结，根据考试要求，摘抄ppt，以及部分自己的理解。&lt;/p&gt;</summary>
    
    
    
    <category term="课内" scheme="http://example.com/categories/%E8%AF%BE%E5%86%85/"/>
    
    <category term="病毒原理与防范" scheme="http://example.com/categories/%E8%AF%BE%E5%86%85/%E7%97%85%E6%AF%92%E5%8E%9F%E7%90%86%E4%B8%8E%E9%98%B2%E8%8C%83/"/>
    
    
    <category term="课内" scheme="http://example.com/tags/%E8%AF%BE%E5%86%85/"/>
    
    <category term="病毒原理与防范" scheme="http://example.com/tags/%E7%97%85%E6%AF%92%E5%8E%9F%E7%90%86%E4%B8%8E%E9%98%B2%E8%8C%83/"/>
    
    <category term="期末总结" scheme="http://example.com/tags/%E6%9C%9F%E6%9C%AB%E6%80%BB%E7%BB%93/"/>
    
  </entry>
  
  <entry>
    <title>记录搭博客的过程</title>
    <link href="http://example.com/2021/05/22/test/"/>
    <id>http://example.com/2021/05/22/test/</id>
    <published>2021-05-22T15:18:24.000Z</published>
    <updated>2021-05-31T13:46:24.351Z</updated>
    
    <content type="html"><![CDATA[<p>记录第一次搭建博客的过程</p><p>遇到太多坑~</p> <center>这是需要居中的文字</center><span id="more"></span><h1 id="hexo-gitee-搭博客"><a href="#hexo-gitee-搭博客" class="headerlink" title="hexo + gitee 搭博客"></a><strong>hexo + gitee 搭博客</strong></h1><p><a href="https://kaiter-plus.gitee.io/2020/03/07/How_To_Freely_Build_Blog/">https://kaiter-plus.gitee.io/2020/03/07/How_To_Freely_Build_Blog/</a></p><p>1.npm换源出现问题</p><p><a href="https://blog.csdn.net/qq_39207948/article/details/79449633">https://blog.csdn.net/qq_39207948/article/details/79449633</a></p><p>2.Git Bash Here里npm install显示没有npm指令</p><p>重载node.js（npm）<a href="https://nodejs.org/en/">https://nodejs.org/en/</a></p><p>3.更换主题：<a href="https://github.com/fluid-dev/hexo-theme-fluid">Fluid</a></p><p><a href="https://zhaowuya.top/">别人Fluid主题的博客</a></p><p>感觉这个主题挺好看的，照着github上的教程搭。</p><p>但是我装完主题之后，本地80端口的博客莫名挂了，然后我又重新部署了一边</p><p><img src="https://gitee.com/cht1/Image/raw/master/20210521204925.png" alt="image-20210521204915030"></p><p>敲完之后，在点开本地博客，主题自动换成刚装的Fluid主题了，真好~<img src="https://gitee.com/cht1/Image/raw/master/20210523010938.gif" alt="img"></p><p>后面要开启pages功能，换了一个教程</p><p><a href="https://oldzhai.gitee.io/2020/03/01/6.hexo+gitee(%E7%A0%81%E4%BA%91)%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%E9%81%BF%E5%BC%80%E6%89%80%E6%9C%89%E5%9D%91/">https://oldzhai.gitee.io/2020/03/01/6.hexo+gitee(%E7%A0%81%E4%BA%91)%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%E9%81%BF%E5%BC%80%E6%89%80%E6%9C%89%E5%9D%91/</a></p><p>但是！！！！md这段时间gitee无法开启pages服务！！！！淦</p><p><img src="https://gitee.com/cht1/Image/raw/master/20210521222117.png" alt="image-20210521222116905"></p><p>nmd，我大nm个寂寞，淦！！。</p><p>心态炸了！！淦！！</p><p>…………………………</p><p>算了，换成github搭博客了……</p><h1 id="hexo-github搭博客"><a href="#hexo-github搭博客" class="headerlink" title="hexo + github搭博客"></a><strong>hexo + github搭博客</strong></h1><p><a href="https://blog.csdn.net/qq_27754983/article/details/76143478">https://blog.csdn.net/qq_27754983/article/details/76143478</a></p><p>没有写开启github pages</p><p><a href="https://zhaowuya.top/2020/01/20/build%20my%20blog/">https://zhaowuya.top/2020/01/20/build%20my%20blog/</a></p><p>fluid主题博主分享</p><p><a href="https://blog.csdn.net/sinat_37781304/article/details/82729029?depth_1-">hexo史上最全搭建教程</a></p><p><a href="https://www.jianshu.com/p/da20ddc03cdf">hexo博客绑定自己的域名</a></p><p>解析设置</p><p><img src="https://gitee.com/cht1/Image/raw/master/20210522111546.png" alt="image-20210522111546637"></p><p>域名配置一定要<strong>实名认证</strong>！！</p><p><a href="https://fluid-dev.github.io/hexo-fluid-docs/guide/#%E5%85%B3%E4%BA%8E%E6%8C%87%E5%8D%97">fluid主题美化</a></p><p>换了个主题</p><p><a href="https://github.com/litten/hexo-theme-yilia">yilia</a></p><p>头像地址<a href="https://www.zhihu.com/question/319182440/answer/952703407">https://www.zhihu.com/question/319182440/answer/952703407</a></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;记录第一次搭建博客的过程&lt;/p&gt;
&lt;p&gt;遇到太多坑~&lt;/p&gt;
 &lt;center&gt;这是需要居中的文字&lt;/center&gt;</summary>
    
    
    
    <category term="日记" scheme="http://example.com/categories/%E6%97%A5%E8%AE%B0/"/>
    
    <category term="Hexo" scheme="http://example.com/categories/%E6%97%A5%E8%AE%B0/Hexo/"/>
    
    <category term="butterfly" scheme="http://example.com/categories/%E6%97%A5%E8%AE%B0/Hexo/butterfly/"/>
    
    
    <category term="博客" scheme="http://example.com/tags/%E5%8D%9A%E5%AE%A2/"/>
    
    <category term="记录" scheme="http://example.com/tags/%E8%AE%B0%E5%BD%95/"/>
    
  </entry>
  
  <entry>
    <title>“firstblog”</title>
    <link href="http://example.com/2021/05/22/%E2%80%9Cfirstblog%E2%80%9D/"/>
    <id>http://example.com/2021/05/22/%E2%80%9Cfirstblog%E2%80%9D/</id>
    <published>2021-05-21T16:40:10.000Z</published>
    <updated>2021-05-30T16:58:28.629Z</updated>
    
    
    
    
    
  </entry>
  
  <entry>
    <title>Hello World</title>
    <link href="http://example.com/2021/05/22/hello-world/"/>
    <id>http://example.com/2021/05/22/hello-world/</id>
    <published>2021-05-21T16:08:52.144Z</published>
    <updated>2021-05-22T13:55:53.186Z</updated>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><span id="more"></span><p>Hello Blog</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;Welcome to &lt;a href=&quot;https://hexo.io/&quot;&gt;Hexo&lt;/a&gt;! This is your very first post. Check &lt;a href=&quot;https://hexo.io/docs/&quot;&gt;documentation&lt;/a&gt; for more info. If you get any problems when using Hexo, you can find the answer in &lt;a href=&quot;https://hexo.io/docs/troubleshooting.html&quot;&gt;troubleshooting&lt;/a&gt; or you can ask me on &lt;a href=&quot;https://github.com/hexojs/hexo/issues&quot;&gt;GitHub&lt;/a&gt;.&lt;/p&gt;</summary>
    
    
    
    
  </entry>
  
</feed>
